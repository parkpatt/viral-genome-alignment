// NWALIGN_H_
// This is the header file for nwalign, a Needleman-Wunsch alignment program.
// All code by Parker J Patterson. Copyright 2020 Parker J Patterson.

#ifndef NWALIGN_H_
#define NWALIGN_H_

/***** MACROS *****/

#define BUF_MAX 8000 // max number of characters that can be aligned
#define MAX_LINE 1024 // used to skip lines that don't contain DNA
#define MAX_ANCHORS 4 // maximum number of anchored sections
#define MAX_SUBSTRINGS MAX_ANCHORS * 2 + 1 // maximum number of substrings 

/***** STRUCTS *****/

struct Step{ 
  int score, x, y;
};
// the Step struct represents one step during the traceback phase.
// positive x means move left; positive y means move up.
// x and y will only ever be 0 or 1.

/***** GLOBAL VARS *****/

char seq1[BUF_MAX]; // container for the first sequence to be aligned
char seq2[BUF_MAX]; // container for the second sequence
char ali_seq1[BUF_MAX]; // aligned sequence 1
char ali_seq2[BUF_MAX]; // aligned sequence 2
int grid[BUF_MAX][BUF_MAX];// seq1 is columns (i), seq2 is rows (j);
int seq1end; // last valid index for sequence 1
int seq2end; // last valid index for sequence 2
int score; // alignment score
int aligned_length; // length of both aligned sequences
int anchor_indices[MAX_ANCHORS][MAX_ANCHORS]; // indices of matched regions
int num_matched_regions; // number of anchored sections in match file
int num_substrings; // = 2 * num_matched_regions + 1
int substring_sizes1[MAX_SUBSTRINGS]; // sizes of substrings for seq1
int substring_sizes2[MAX_SUBSTRINGS]; // sizes of substrings for seq2
int sum_scores_substrings; // sum of the alignment scores of substrings
char seq1_holder[BUF_MAX]; // stores a copy of seq1 so that seq1 can be altered
char seq2_holder[BUF_MAX]; // stores a copy of seq2 so that seq2 can be altered

/***** FUNCTIONS *****/

int main(int argc, char* argv[]);
// if 2 arguments are passed, nwalign runs standard Needleman-Wunsch

int ReadFna(char* path, char* buffer);
// reads the genome from 'path' into the character array pointed
// to by 'buffer.' Returns the number of nucleotides read. In the main
// routine, we pass the global character arrays seq1 and as the 'buffer'
// argument in two calls to Readfna -- one for each sequence,.

void InitGrid();
// initalizes the grid matrix for holding alignment scores

int max3(int a, int b, int c);
// returns the largest of three integers
// used in FillGrid and GenerateAlignments

void FillGrid();
// populates the 'grid' global variable with alignment scores using Needleman-
// Wunsch algorithm. Match score, indel penalty, and mismatch penalty are each
// hardcoded as local variables with the values 1, -2, and -3, respectively.

void PrintGrid();
// prints the Needleman-Wunsch grid to stdout for debugging purposes.
// WARNING: designed for small test files only -- large sequences have massive
// grids and the output won't be readable.

void GenerateAlignments();
// uses the Needleman-Wunsch "traceback" method to find the best alignment for
// the two sequences passed as input to nwalign. GenerateAlignments assumes that
// these sequences are already stored in the global character arrays seq1 and 
// seq2 before GenerateAlignments is called. The global integer variables 
// seq1end and seq2end are used as the last valid indices of these sequences.

void PrintSequences();
// debugging tool. Prints the contents of seq1 and seq2 global char arrays.
// Should only be called after ReadFna has been called twice, once on each
// fna input file.

void PrintResults();
// debugging tool. Prints the alignment results generated by GenerateAlignments.
// Should only be called after GenerateAlignments has been called at least once.

void WriteResults(char* filename1, char* filename2);
// writes the results from GenerateAlignments to a file "results.txt". Arguments
// are the names of the original input files.

void RecordScore();
// appends the value stored in the global integer variable 'score' to a file
// called "scores.txt". RecordScore creates "scores.txt" if it does not exist
// yet. This function is used for the portion of the assignment which requires
// us to re-run Needleman-Wunsch alignment on randomly permuted sequences.

void PermuteSequence(char* seq, int len);
// randomly permutes the character array 'seq' with length 'len'

void ParseMatchFile(char* path);
// reads anchor data from a file, storing it in the global int array
// 'anchor_indices'. Sets num_matched_regions = number of index-containing lines
// in the input file. Sets num_substrings = 2 * num_matched_regions + 1.
// num_substrings refers to the number of substrings that will be needed to
// split the DNA sequences seq1 and seq2 according to the number of matched
// regions.

void CalculateSizes();
// calculates the sizes of the substrings needed to split seq1 and seq2 based on
// the number of matched regions detected in ParseMatchFile.

void ReportOnMatchFile();
// debugging tool. Prints info gathered in ParseMatchFile.

void RecordPartialAlignment(int section_no);
// appends the score and alignment for a substring to a file 
// "anchored-results.txt", or creates one, if it does not exist. Used to 
// generate results for the anchored alignment portion of the assignment.

#endif //NWALIGN_H_
