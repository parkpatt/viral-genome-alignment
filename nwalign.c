// NWALIGN_C_
// This is the C file for nwalign, a Needleman-Wunsch alignment program.
// All code by Parker J Patterson. Copyright 2020 Parker J Patterson.
// For more information on macros, structs, global variables and functions
// please refer to nwalign.h.

#include "nwalign.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char* argv[]){
  if (argc == 3){
    seq1end = ReadFna(argv[1], seq1);
    seq2end = ReadFna(argv[2], seq2);
    //PrintSequences();
    InitGrid();
    FillGrid();
    //PrintGrid();
    GenerateAlignments();
    //PrintResults();
    WriteResults(argv[1],argv[2]);
    // uncomment this section to run NW alignment on 100 randomly permuted seqs
    /* FILE* scores = fopen("scores.csv", "w"); */
    /* fclose(scores); // reset file in case of earlier operations */
    /* for (int i = 0; i < 100; i++){ */
    /*   PermuteSequence(seq1, seq1end); */
    /*   PermuteSequence(seq2, seq2end); */
    /*   InitGrid(); */
    /*   FillGrid(); */
    /*   GenerateAlignments(); */
    /*   RecordScore(); */
    /* } */    
  } else if (argc == 4){
    sum_scores_substrings = 0;
    seq1end = ReadFna(argv[1], seq1);
    strncpy(seq1_holder, seq1, seq1end);
    seq2end = ReadFna(argv[2], seq2);
    strncpy(seq2_holder, seq2, seq2end);
    ParseMatchFile(argv[3]);
    CalculateSizes();
    //ReportOnMatchFile();
    FILE* results = fopen("anchored-results.txt", "w");
    fclose(results); // open in write mode and immediately close to reset file
    for (int i = 0; i < num_substrings; i++){
      // offsets into seq1 and seq2 for the current substring
      int offset1 = i == 0 ? 0 : anchor_indices[0][(i-1)/2];
      int offset2 = i == 0 ? 0 : anchor_indices[2][(i-1)/2];
      // move substrings into seq1 and seq2 and reset seq1end, seq2end
      strncpy(seq1, &seq1_holder[offset1], substring_sizes1[i]);
      strncpy(seq2, &seq2_holder[offset2], substring_sizes2[i]);
      seq1end = substring_sizes1[i];
      seq2end = substring_sizes2[i];
      // generate alignments
      InitGrid();
      FillGrid();
      GenerateAlignments();
      //only record results for non-anchored section
      if (i%2 == 0)
	RecordPartialAlignment(i); 
      sum_scores_substrings += score;
    }
    results = fopen("anchored-results.txt", "a");
    fprintf(results, "\ntotal score: %d\n", sum_scores_substrings);
    fclose(results);
  } else {
    return -1;
  }
  return 1;
}

int ReadFna(char* path, char* buffer){
  char linebuf[MAX_LINE]; // used to skip lines
  FILE* in_file = fopen(path, "r");
  int charcount = 0;
  char* p = fgets(linebuf, MAX_LINE, in_file); // throw away first line (blank)
  //fgets(linebuf, MAX_LINE, inFile);
  //printf("%s", linebuf);
  while(!feof(in_file)){
    char currChar = fgetc(in_file);
    if (currChar == EOF) break;
    if (currChar == '\n') break;
    strncat(buffer, &currChar, 1);
    charcount++;
  }
  buffer[charcount] = '\0';
  fclose(in_file);
  return charcount;
}

void InitGrid(){
  for (int i = 0; i <= seq1end; i++){
    grid[i][0] = -2 * i;
  }
  for (int i = 0; i <= seq2end; i++){
    grid[0][i] = -2 * i;
  }
}

int max3(int a, int b, int c){
  int tmp;
  if (a > b)
    tmp = a;
  else
    tmp = b;
  if (tmp > c)
    return tmp;
  else
    return c;
}

void FillGrid(){
  int match_score = 1;
  int indel_penalty = -2;
  int mismatch_penalty = -3;
  int scoretop; // score generated by moving from the entry above
  int scoreleft; // score generated by moving from the entry left
  int scorediag; // score generated by moving diagonally
  for (int i = 1; i <= seq1end; i++){
    for (int j = 1; j <= seq2end; j++){
      //penalty = (seq1[i] == seq2[j]) ? 1 : -3;
      scoretop = grid[i][j - 1] + indel_penalty;
      scoreleft = grid[i - 1][j] + indel_penalty;
      if (seq1[i - 1] == seq2[j - 1]){
	scorediag = grid[i - 1][j - 1] + match_score;
      } else {
	scorediag = grid[i - 1][j - 1] + mismatch_penalty;
      }
      grid[i][j] = max3(scoretop, scoreleft, scorediag);
    }    
  }    
}

void PrintGrid(){
  printf("grid:\n      ");
  for (int i = 0; i < seq1end; i++){
    printf("%5c", seq1[i]);
  }
  printf("\n");
  for (int j = 0; j <= seq2end; j++){
    if (j == 0)
      printf(" ");
    else
      printf("%c", seq2[j - 1]);
    for (int i = 0; i <= seq1end; i++){
      printf("%5d", grid[i][j]);
    }
    printf("\n");
  }
}

void GenerateAlignments(){
  aligned_length = 0; // records the length of the aligned sequence with gaps
  int i = seq1end; 
  int j = seq2end; 
  int ali_idx = BUF_MAX - 1;
  score = grid[i][j]; // score starts out equal to lower-rightmost entry

  while(i != 0 && j != 0){
    // the Step struct is a way to represent the three choices available at each
    // iteration of the traceback algorithm: left, diagonal, or up.
    struct Step left = {grid[i - 1][j]    , 1, 0};
    struct Step diag = {grid[i - 1][j - 1], 1, 1};
    struct Step up   = {grid[i]    [j - 1], 0, 1};
    struct Step *chosen; // points to whichever option has best score 
    int best = max3(left.score, diag.score, up.score);

    // this if/else block builds the aligned sequences based on the best score
    if (best == left.score){
      chosen = &left;
      ali_seq1[ali_idx] = seq1[i - 1];
      ali_seq2[ali_idx] = '-';
    } else if (best == diag.score){
      chosen = &diag;
      ali_seq1[ali_idx] = seq1[i - 1];
      ali_seq2[ali_idx] = seq2[j - 1];
    }else {
      chosen = &up;
      ali_seq1[ali_idx] = '-';
      ali_seq2[ali_idx] = seq2[j - 1];
    }

    // modify iterators and add score 
    score += chosen->score;
    i -= chosen->x;
    j -= chosen->y;
    ali_idx--;
    aligned_length++;

    // overflow-handling
    if (aligned_length >= BUF_MAX){
      fprintf(stderr,"overflow error. make BUF_MAX larger.\n");
      exit(1);
    }
  }
  // since ali_seq1 and ali_seq2 were built starting from the highest index and
  // working backward, we now have to move them to the front of their arrays
  // with memmove. A null-byte is also appended here.
  memmove(&ali_seq1, &ali_seq1[ali_idx + 1], aligned_length);
  memmove(&ali_seq2, &ali_seq2[ali_idx + 1], aligned_length);
  ali_seq1[aligned_length] = '\0';
  ali_seq2[aligned_length] = '\0';
}

void PrintSequences(){
  printf("sequence 1:\n%s\nsequence 2:\n%s\n\n",
	 seq1, seq2);
}

void PrintResults(){
  printf("aligned sequence length: %d\n", aligned_length);
  printf("score: %d\n\n", score);
  printf("aligned sequence 1:\n%s\n\naligned sequence 2:\n%s\n\n",
	 ali_seq1,ali_seq2);
}

void WriteResults(char* filename1, char* filename2){
  FILE* results = fopen("results.txt", "w");
  fprintf(results,
	  "Needleman-Wunsch Alignment Results for %s and %s\nThis file was created by nwalign, a Needleman Wunsch Alignment implementation in C by Parker J Patterson.\n",
	  filename1, filename2);
  fprintf(results,
	  "Alignment score: %d\nSequence 1 original length: %d\nSequence 2 original length: %d\nAligned length of both sequences: %d\n\n",
	  score, seq1end, seq2end, aligned_length
	  );
  fprintf(results,"Aligned sequence 1: %s\n\n", ali_seq1);
  fprintf(results,"Aligned sequence 2: %s", ali_seq2);
}

void RecordScore(){
  FILE* out_file = fopen("scores.csv", "a");
  fprintf(out_file, "%d,", score);
  fclose(out_file);
}

void PermuteSequence(char* seq, int len){
  for (int i = 0; i < len; i ++){
    int random_index = rand() % len;
    char tmp = seq[random_index];
    seq[random_index] = seq[i];
    seq[i] = tmp;
  }
}

void ParseMatchFile(char* path){
  num_matched_regions = 0; // initialize global int 'num_matched_regions'
  FILE* file = fopen(path, "r");
  char line_buffer[MAX_LINE];
  char* index_buffer;
  int i = 0; // used to index the 'anchor_indices' global array
  int j = 0;
  char* p = fgets(line_buffer, MAX_LINE, file); // throw away first line
  while(!feof(file)){
    i = 0;
    if (fgets(line_buffer, MAX_LINE, file) == NULL) break;   
    index_buffer = strtok(line_buffer,"\t\n");    
    while (index_buffer != NULL){     
      anchor_indices[i][j] = atoi(index_buffer);
      index_buffer = strtok(NULL, "\t\n");
      i++;
    }
    j++;
  }
  num_matched_regions = j;
  num_substrings = 2 * num_matched_regions + 1;
  fclose(file);
}

void CalculateSizes(){
  substring_sizes1[0] = anchor_indices[0][0];
  substring_sizes2[0] = anchor_indices[2][0];
  for (int i = 1; i < num_substrings - 1; i++){
    if (i % 2 == 0){
      substring_sizes1[i] = anchor_indices[0][i/2] - anchor_indices[1][i/2-1];
      substring_sizes2[i] = anchor_indices[2][i/2] - anchor_indices[3][i/2-1];
    } else {
      substring_sizes1[i] = anchor_indices[1][(i-1)/2] - anchor_indices[0][(i-1)/2];
      substring_sizes2[i] = anchor_indices[3][(i-1)/2] - anchor_indices[2][(i-1)/2];
    }
  }
  substring_sizes1[num_substrings - 1] =
    seq1end - anchor_indices[1][num_matched_regions - 1];
  substring_sizes2[num_substrings - 1] =
    seq2end - anchor_indices[3][num_matched_regions - 1];
}

void ReportOnMatchFile(){
  printf("Matched regions: %d\n", num_matched_regions);
  printf("Number of substrings: %d\n", num_substrings);
  printf("anchor_indices:\n");
  for (int j = 0; j < num_matched_regions; j++){
    for (int i = 0; i < 4; i++){
      printf("%5d",anchor_indices[i][j]);
    }
    printf("\n");
  }
  printf("substring sizes:\n");
  printf("  1   2\n");
  for (int i = 0; i < num_substrings; i++){
    printf("%4d%4d\n",substring_sizes1[i],substring_sizes2[i]);
  }
}

void RecordPartialAlignment(int section_no){
  FILE* out_file = fopen("anchored-results.txt", "a");
  fprintf(out_file, "Section: %d\nLocal alignment score:%d\n\n", section_no, score);
  fprintf(out_file,"Sequence 1:%s\n\n", ali_seq1);
  fprintf(out_file,"Sequence 2:%s\n\n", ali_seq2);
  fclose(out_file);
}
